package main

import "fmt"

type NodeStoringImplicitDepLoader struct {
	ImplicitDepLoader
	dep_nodes_output_ []*Node
}
func NewNodeStoringImplicitDepLoader(state * State, deps_log *DepsLog, disk_interface DiskInterface,
       depfile_parser_options *DepfileParserOptions, explanations *Explanations, dep_nodes_output []*Node) *NodeStoringImplicitDepLoader {
	ret := NodeStoringImplicitDepLoader{}
	ImplicitDepLoader = NewImplicitDepLoader(state, deps_log, disk_interface, depfile_parser_options, explanations)
	ret.dep_nodes_output_ = dep_nodes_output
	return &ret
}
        
func(this*NodeStoringImplicitDepLoader) ProcessDepfileDeps(edge *Edge, depfile_ins []string, err *string) bool {
  for (std::vector<StringPiece>::iterator i = depfile_ins.begin(); i != depfile_ins.end(); ++i) {
    slash_bits := uint64(0)
	CanonicalizePath(const_cast<char*>(i.str_), &i.len_, &slash_bits);
    node := this.state_.GetNode(*i, slash_bits)
		this.dep_nodes_output_.push_back(node)
  }
  return true;
}

type MissingDependencyScannerDelegate interface {
	ReleaseMissingDependencyScannerDelegate()
	OnMissingDep(node *Node, path string, generator *Rule)
}

type MissingDependencyPrinter struct {
	MissingDependencyScannerDelegate
}

func (this *MissingDependencyPrinter) OnMissingDep(node *Node, path string, generator *Rule) {
	  fmt.Sprintf("Missing dep: " + node.path() + " uses " + path + " (generated by " + generator.name() + ")\n")
}
func (this *MissingDependencyPrinter) OnStats(nodes_processed, nodes_missing_deps,
	missing_dep_path_count, generated_nodes,
	generator_rules int) {
}

type InnerAdjacencyMap map[*Edge]bool
type AdjacencyMap map[*Edge]InnerAdjacencyMap
type MissingDependencyScanner struct {
	delegate_               *MissingDependencyScannerDelegate
	deps_log_               *DepsLog
	state_                  *State
	disk_interface_         DiskInterface
	seen_                   map[*Node]bool
	nodes_missing_deps_     map[*Node]bool
	generated_nodes_        map[*Node]bool
	generator_rules_        map[*Node]bool
	missing_dep_path_count_ int

	adjacency_map_ AdjacencyMap
}

func NewMissingDependencyScanner(delegate MissingDependencyScannerDelegate, deps_log *DepsLog, state *State, disk_interface DiskInterface) *MissingDependencyScanner {
	ret := MissingDependencyScanner{}
delegate_(delegate), deps_log_(deps_log), state_(state),
      disk_interface_(disk_interface), missing_dep_path_count_(0)
	return &ret
}
func (this *MissingDependencyScanner) ProcessNode(node *Node) {
  if (!node)
    return;
  Edge* edge = node.in_edge();
  if (!edge)
    return;
  if (!seen_.insert(node).second)
    return;

  for (std::vector<Node*>::iterator in = edge.inputs_.begin();
       in != edge.inputs_.end(); ++in) {
    ProcessNode(*in);
  }

  std::string deps_type = edge.GetBinding("deps");
  if (!deps_type.empty()) {
    DepsLog::Deps* deps = deps_log_.GetDeps(node);
    if (deps)
      ProcessNodeDeps(node, deps.nodes, deps.node_count);
  } else {
    DepfileParserOptions parser_opts;
    std::vector<Node*> depfile_deps;
    NodeStoringImplicitDepLoader dep_loader(state_, deps_log_, disk_interface_,
                                            &parser_opts, nullptr,
                                            &depfile_deps);
    std::string err;
    dep_loader.LoadDeps(edge, &err);
    if (!depfile_deps.empty())
      ProcessNodeDeps(node, &depfile_deps[0], depfile_deps.size());
  }
}
func (this *MissingDependencyScanner) PrintStats()            {
  std::cout << "Processed " << seen_.size() << " nodes.\n";
  if (HadMissingDeps()) {
    std::cout << "Error: There are " << missing_dep_path_count_
              << " missing dependency paths.\n";
    std::cout << nodes_missing_deps_.size()
              << " targets had depfile dependencies on "
              << generated_nodes_.size() << " distinct generated inputs "
              << "(from " << generator_rules_.size() << " rules) "
              << " without a non-depfile dep path to the generator.\n";
    std::cout << "There might be build flakiness if any of the targets listed "
                 "above are built alone, or not late enough, in a clean output "
                 "directory.\n";
  } else {
    std::cout << "No missing dependencies on generated files found.\n";
  }
}

func (this *MissingDependencyScanner) HadMissingDeps() bool {
	return len(this.nodes_missing_deps_) != 0
}

func (this *MissingDependencyScanner) ProcessNodeDeps(node *Node, dep_nodes **Node, dep_nodes_count int) {
  Edge* edge = node.in_edge();
  std::set<Edge*> deplog_edges;
  for (int i = 0; i < dep_nodes_count; ++i) {
    Node* deplog_node = dep_nodes[i];
    // Special exception: A dep on build.ninja can be used to mean "always
    // rebuild this target when the build is reconfigured", but build.ninja is
    // often generated by a configuration tool like cmake or gn. The rest of
    // the build "implicitly" depends on the entire build being reconfigured,
    // so a missing dep path to build.ninja is not an actual missing dependency
    // problem.
    if (deplog_node.path() == "build.ninja")
      return;
    Edge* deplog_edge = deplog_node.in_edge();
    if (deplog_edge) {
      deplog_edges.insert(deplog_edge);
    }
  }
  std::vector<Edge*> missing_deps;
  for (std::set<Edge*>::iterator de = deplog_edges.begin();
       de != deplog_edges.end(); ++de) {
    if (!PathExistsBetween(*de, edge)) {
      missing_deps.push_back(*de);
    }
  }

  if (!missing_deps.empty()) {
    std::set<std::string> missing_deps_rule_names;
    for (std::vector<Edge*>::iterator ne = missing_deps.begin();
         ne != missing_deps.end(); ++ne) {
      for (int i = 0; i < dep_nodes_count; ++i) {
        if (dep_nodes[i].in_edge() == *ne) {
          generated_nodes_.insert(dep_nodes[i]);
          generator_rules_.insert(&(*ne).rule());
          missing_deps_rule_names.insert((*ne).rule().name());
          delegate_.OnMissingDep(node, dep_nodes[i].path(), (*ne).rule());
        }
      }
    }
    missing_dep_path_count_ += missing_deps_rule_names.size();
    nodes_missing_deps_.insert(node);
  }
}

func (this *MissingDependencyScanner) PathExistsBetween(from, to *Edge) bool {
  AdjacencyMap::iterator it = adjacency_map_.find(from);
  if (it != adjacency_map_.end()) {
    InnerAdjacencyMap::iterator inner_it = it.second.find(to);
    if (inner_it != it.second.end()) {
      return inner_it.second;
    }
  } else {
    it = adjacency_map_.insert(std::make_pair(from, InnerAdjacencyMap())).first;
  }
  bool found = false;
  for (size_t i = 0; i < to.inputs_.size(); ++i) {
    Edge* e = to.inputs_[i].in_edge();
    if (e && (e == from || PathExistsBetween(from, e))) {
      found = true;
      break;
    }
  }
  it.second.insert(std::make_pair(to, found));
  return found;
}
